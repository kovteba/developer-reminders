ifndef::imagesdir[:imagesdir: source/imgs/]

[#service-discovery]
=== Service Discovery

image::architecture/service-discovery.jpg[Service Discovery, align="center"]

[[service-discovery-definition]]*Service Discovery* — це механізм, який дозволяє автоматично знаходити та підключатися до сервісів у розподілених системах, таких як Docker Swarm або Kubernetes. Це особливо важливо в середовищах, де сервіси можуть динамічно змінювати IP-адресу, масштабуватися або переміщуватися між різними вузлами.

Наприклад, якщо у вас є сервіси _user-service_, _payment-service_ та _email-service_, і сервіс _payment-service_ хоче зв’язатися з _user-service_, то без Service Discovery потрібно вручну вказувати IP-адресу, наприклад: `http://192.168.0.15:8080`. Але якщо IP-адреса зміниться, _payment-service_ більше не зможе знайти _user-service_. Завдяки Service Discovery _payment-service_ може звернутися до _user-service_ за його логічною назвою: `http://user-service:8080`, і система автоматично знайде правильну IP-адресу та порт.

[[service-discovery-types]]
Основні типи *Service Discovery*:

* <<client-side-discovery,Client-side discovery>>;
* <<server-side-discovery,Server-side discovery>>;
* <<dns-based-discovery,DNS-based discovery>>;
* <<key-value-store-based-discovery,Key-Value Store-based discovery>>.


[[client-side-discovery]]
*Client-side discovery* (клієнтське виявлення) — це підхід до Service Discovery, при якому клієнт (тобто сервіс, який хоче знайти інший сервіс) самостійно звертається до сервісного реєстру, отримує список доступних інстансів потрібного сервісу і вибирає, до якого з них підключитися. У цьому випадку клієнт не покладається на проміжний проксі або шлюз для маршрутизації запитів. Прикладами систем, які використовують client-side discovery, є Netflix Eureka у поєднанні з Ribbon, а також клієнтські API Consul.

[[client-side-discovery-how-it-works]]
Як працює *Client-side discovery*:

1. Сервіс реєструє себе в сервісному реєстрі (наприклад, Eureka, Consul) при запуску, надаючи інформацію про своє розташування (IP-адресу, порт, метадані).
2. Коли клієнтський сервіс хоче звернутися до іншого сервісу, він запитує сервісний реєстр, щоб отримати список доступних інстансів цього сервісу.
3. Клієнт отримує список інстансів і використовує алгоритм балансування навантаження (наприклад, round-robin, random) для вибору одного з них.
4. Клієнт встановлює пряме з’єднання з обраним інстансом і виконує запит.
5. Якщо обраний інстанс недоступний, клієнт може повторити запит до сервісного реєстру, щоб отримати оновлений список інстансів і спробувати знову.

[source,java]
----
RestTemplate template = new RestTemplate();
String url = "http://user-service"; // логічне ім’я
----

Spring Cloud з Eureka + Ribbon автоматично знайде IP.

[[client-side-discovery-pros-and-cons]]
Переваги та недоліки *Client-side discovery*:

Переваги:

* Меньше навантаження на проміжні проксі, оскільки клієнт самостійно вибирає інстанс;
* Гнучкість у виборі алгоритмів балансування навантаження на стороні клієнта;
* Пряме з’єднання між клієнтом і сервісом, що може знизити затримки.

Недоліки:

* Кожен клієнт повинен мати логіку для взаємодії з сервісним реєстром, що ускладнює клієнтський код;
* Залежність від конкретного стека (наприклад, Eureka → Java only);
* Потрібно оновлювати всі клієнти при зміні логіки.

[[server-side-discovery]]
*Server-side discovery* (серверне виявлення) — це підхід до Service Discovery, при якому клієнтський сервіс звертається до проміжного проксі або шлюзу, а цей проміжний компонент самостійно виконує запит до сервісного реєстру та переспрямовує запит до потрібного інс��ансу сервісу. У цьому випадку клієнт не має прямого доступу до сервісного реєстру і не відповідає за вибір інстансу. Прикладами систем, які використовують server-side discovery, є Kubernetes (через kube-proxy і DNS), Envoy та Istio.

[[server-side-discovery-how-it-works]]
Як працює *Server-side discovery*:

1. Сервіс реєструє себе в сервісному реєстрі (наприклад, Kubernetes API Server, Consul) при запуску, надаючи інформацію про своє розташування (IP-адресу, порт, метадані).
2. Клієнтський сервіс звертається до проміжного проксі або шлюзу, вказуючи логічне ім’я потрібного сервісу (наприклад, через DNS-ім’я або URL).
3. Проксі або шлюз запитує сервісний реєстр, щоб отримати список доступних інстансів цього сервісу.
4. Проксі або шлюз використовує алгоритм балансування навантаження (наприклад, round-robin, random) для вибору одного з інстансів.
5. Проксі або шлюз встановлює з’єднання з обраним інстансом і переспрямовує запит від клієнта.
6. Якщо обраний інстанс недоступний, проксі або шлюз може повторити запит до сервісного реєстру, щоб отримати оновлений список інстансів і спробувати знову.

[source,java]
----
RestTemplate template = new RestTemplate();
String url = "http://gateway/user-service"; // через API Gateway
----

API Gateway (наприклад, Zuul, Kong) або сервісна сітка (наприклад, Istio) автоматично знайде IP.

[[server-side-discovery-pros-and-cons]]
Переваги та недоліки *Server-side discovery*:

Переваги:

* Спрощення клієнтського коду, оскільки клієнт не потребує логіки для взаємодії з сервісним реєстром;
* Централізоване управління маршрутизацією та балансуванням навантаження на стороні проксі або шлюзу;
* Легше впроваджувати політики безпеки, моніторинг і логування на рівні проксі або шлюзу.

Недоліки:

* Додаткове навантаження на проміжні проксі або шлюзи, що може стати вузьким місцем у системі;
* Затримки через додатковий рівень маршрутизації між клієнтом і сервісом;
* Залежність від надійності проміжного компонента (проксі або шлюзу).

[[dns-based-discovery]]
*DNS-based discovery* (виявлення на основі DNS) — це підхід до Service Discovery, при якому сервіси знаходять один одного за допомогою DNS-запитів. У цьому випадку кожен сервіс реєструється в DNS-системі з унікальним ім’ям, і клієнтські сервіси можуть звертатися до інших сервісів, використовуючи ці імена. DNS-система автоматично розв’язує ці імена в актуальні IP-адреси інстансів сервісів. Цей підхід широко використовується в Kubernetes (через CoreDNS) та Docker Swarm.

[[dns-based-discovery-how-it-works]]
Як працює *DNS-based discovery*:

1. Сервіс реєструє себе в DNS-системі при запуску, надаючи унікальне ім’я (наприклад, `user-service.default.svc.cluster.local` у Kubernetes).
2. Клієнтський сервіс звертається до іншого сервісу, використовуючи його DNS-ім’я.
3. DNS-система розв’язує це ім’я в актуальні IP-адреси інстансів сервісу.
4. Клієнт встановлює з’єднання з одним з отриманих IP-адрес і виконує запит.
5. Якщо інстанс недоступний, клієнт може повторити DNS-запит, щоб отримати оновлений список IP-адрес.

[source,java]
----
RestTemplate template = new RestTemplate();
String url = "http://user-service.default.svc.cluster.local"; // DNS-ім’я
----

Kubernetes (через CoreDNS) автоматично знайде IP.

[[dns-based-discovery-pros-and-cons]]
Переваги та недоліки *DNS-based discovery*:

Переваги:

* Широке використання та підтримка в багатьох системах (Kubernetes, Docker Swarm);
* Простота використання, оскільки DNS є стандартним механізмом у мережах;
* Автоматичне оновлення IP-адрес через TTL записів у DNS.

Недоліки:

* Затримки через DNS-запити, особливо якщо TTL високий і записи не оновлюються швидко;
* Обмежена гнучкість у виборі алгоритмів балансування навантаження (залежить від можливостей DNS-сервера);
* Можливі проблеми з кешуванням DNS на стороні клієнта, що може призводити до використання застарілих IP-адрес.

[[key-value-store-based-discovery]]
*Key-Value Store-based discovery* (виявлення на основі сховища ключ-значення) — це підхід до Service Discovery, при якому сервіси реєструють свої інстанси в розподіленому сховищі ключ-значення (наприклад, Consul, Etcd, Zookeeper). Клієнтські сервіси звертаються до цього сховища, щоб отримати інформацію про доступні інстанси інших сервісів. Цей підхід забезпечує високу доступність і консистентність даних про сервіси.

[[key-value-store-based-discovery-how-it-works]]
Як працює *Key-Value Store-based discovery*:

1. Сервіс реєструє себе в сховищі ключ-значення при запуску, створюючи запис з унікальним ключем (наприклад, `services/user-service/instance-id`) і значенням, що містить інформацію про розташування (IP-адресу, порт, метадані).
2. Клієнтський сервіс звертається до сховища ключ-значення, щоб отримати список доступних інстансів потрібного сервісу.
3. Клієнт отримує список інстансів і використовує алгоритм балансування навантаження (наприклад, round-robin, random) для вибору одного з них.
4. Клієнт встановлює пряме з’єднання з обраним інстансом і виконує запит.
5. Якщо обраний інстанс недоступний, клієнт може повторити запит до сховища ключ-значення, щоб отримати оновлений список інстансів і спробувати знову.

[source,java]
----
RestTemplate template = new RestTemplate();
String url = "http://user-service"; // логічне ім’я
----

Consul API або інший клієнт автоматично знайде IP.

[[key-value-store-based-discovery-pros-and-cons]]
Переваги та недоліки *Key-Value Store-based discovery*:

Переваги:

* Висока доступність і консистентність даних про сервіси завдяки розподіленій природі сховищ ключ-значення;
* Гнучкість у виборі алгоритмів балансування навантаження на стороні клієнта;
* Підтримка складних сценаріїв, таких як health checks і метадані сервісів.

Недоліки:

* Додаткова складність у налаштуванні та управлінні сховищем ключ-значення;
* Залежність від надійності та продуктивності сховища ключ-значення;
* Потрібно оновлювати всі клієнти при зміні логіки взаємодії зі сховищем.

[[service-discovery-types-comparison]]
|====
|Критерій                   |Client-side|Server-side        |DNS-based              |KV Store-based
|Складність на клієнті      |Висока     |Низька             |Низька                 |Висока
|Потрібна підтримка проксі  |Ні         |Так                |Ні                     |Ні
|Балансування трафіку       |Гнучке     |Централізоване     |Базове (round-robin)   |Вручну або зовнішнє
|Підтримка мов / стеків     |Обмежена   |Будь-яка           |Будь-яка               |Через SDK/API
|Залежність від бібліотек   |Є          |Відсутня           |Відсутня               |Є (наприклад, gRPC+etcd)
|Контроль з боку DevOps     |Складно    |Повний контроль    |Обмежено               |Повний контроль
|Продуктивність             |Висока     |Нижча через проксі |Висока                 |Висока (без проксі)
|====

Service Discovery відповідає двом з 2 властивостей <<cap-theory,CAP-теорії>>:

1. Бути доступними (A), щоб клієнти могли завжди знайти потрібний сервіс.
2. Бути узгодженими (C), щоб уникнути фальшивих або застарілих записів.

Але при мережевому розділенні (P), доводиться обирати:

* *Consul*/*Etcd*/*Zookeeper* —> *CP системи*: пріоритет консистентності. Краще зупинити запис, ніж допустити помилкову інформацію.
* **DNS-based discovery** —> *AP системи*: завжди дає відповідь, але може бути застарілою (через TTL, кешування).

[[service-discovery-where-used]]
Де використовується *Service Discovery*:

* *Docker Swarm*: має вбудований механізм Service Discovery, що дозволяє сервісам знаходити один одного за іменами;
* *Kubernetes*: використовує вбудовану DNS-систему (CoreDNS) для автоматичного розв’язання імен сервісів;
* *Consul*, *Etcd*, *Zookeeper*: зовнішні системи Service Discovery, які можуть бути інтегровані з Docker, Kubernetes або іншими платформами;
* *AWS Cloud Map*, *Google Cloud Service Directory*: хмарні сервіси для управління реєстрацією та виявленням сервісів у масштабованих інфраструктурах.

[[service-discovery-what-for]]
Що дає *Service Discovery*:

* *Автоматизація*: зменшує потребу в ручному налаштуванні мережевих адрес;
* *Балансування навантаження*: деякі системи Service Discovery можуть автоматично розподіляти трафік між кількома інстансами сервісу;
* *Failover*: забезпечує автоматичне перенаправлення трафіку у випадку відмови одного з інстансів сервісу;
* *Горизонтальне масштабування*: дозволяє легко додавати або видаляти інстанси сервісу без необхідності змінювати конфігурацію клієнтів.

[[service-discovery-tools]]
Приклади інструментів *Service Discovery*:

* *Docker Swarm*: має вбудований механізм Service Discovery на основі DNS;
* *Kubernetes DNS (CoreDNS)*: вбудована DNS-система для автоматичного розв’язання імен сервісів у кластері;
* *Consul*: потужний інструмент для Service Discovery, health-check-ів та централізованого зберігання конфігурацій;
* *etcd*: розподілене key-value сховище, що використовується Kubernetes для зберігання конфігурації кластера, включно з даними для Service Discovery;
* *Zookeeper*: використовується для координації розподілених систем і як механізм Service Discovery (наприклад, у Kafka, Hadoop);
* *Eureka*: сервісний реєстр, який широко використовується в екосистемі Spring Cloud.

[[service-discovery-main-components]]
Головні компоненти *Service Discovery*:

* *Реєстратор сервісів (Service Registrar)*: компонент, який відповідає за реєстрацію нових інстансів сервісу в реєстрі та їх видалення у разі зупинки або збою;
* *Сервіс (Service)*: застосунок або мікросервіс, який реєструється в системі Service Discovery;
* *Клієнт Service Discovery*: компонент (або бібліотека), який дозволяє сервісам знаходити інші сервіси за їх логічними іменами;
* *Health Checks*: механізми перевірки стану інстансів сервісів, які гарантують, що клієнти взаємодіють лише з працездатними інстансами;
* *Інтерфейс доступу (DNS або API)*: спосіб, через який клієнти отримують інформацію про доступні сервіси (наприклад, через DNS-імена або REST/gRPC API).



















✅ 4. Service Discovery vs API Gateway vs Service Mesh

Компонент	Основна функція
Service Discovery	Знаходить інстанси сервісів
API Gateway	Виступає єдиною точкою входу для клієнтів
Service Mesh	Контролює трафік між сервісами на рівні L7 (часто в тандемі з discovery)

➡️ Поясни, чому Service Mesh (наприклад, Istio, Linkerd) не замінює, а доповнює Service Discovery.

⸻

✅ 5. Failure Scenarios & Resilience
•	Що буде, якщо зникне весь кластер Consul?
•	Як Kubernetes відновлює DNS CoreDNS pod?
•	Як будувати circuit breakers, retries, timeouts при використанні Service Discovery?

⸻

✅ 6. Роль DNS у Service Discovery
•	Чим DNS-базований discovery відрізняється від API?
•	Що таке SRV-записи? Як працює dnsRoundRobin?
•	TTL-залежна кешованість: потенційна проблема в stale-записах

⸻

✅ 7. Безпека Discovery
•	Хто може реєструвати сервіси?
•	Може зловмисник зареєструвати фейковий auth-service?
•	Як захистити доступ до Registry? (mTLS, ACL, JWT)

⸻

✅ 8. Інструменти з досвідом використання

🎯 Senior має хоча б базовий продакшн-досвід з одним із:

Інструмент	Що треба знати
Consul	ACL, DNS, health checks, sync modes
Eureka	Self-preservation mode, client cache
Kubernetes	CoreDNS, headless services, SRV-записи
Zookeeper	ZNode, ephemeral nodes, leader election


⸻

✅ 9. Класичні питання з інтерв’ю
•	Поясни різницю між client-side і server-side discovery.
•	Як ти реалізуєш zero-downtime deployment, якщо IP змінюється?
•	Що буде, якщо один з інстансів сервісу не працює, але ще зареєстрований?
•	Чим Kubernetes service discovery відрізняється від Eureka/Consul?

⸻

✅ 10. Тестове завдання або whiteboard:

“Розроби систему, яка динамічно додає і видаляє інстанси сервісу при автоскейлінгу. Клієнти не повинні знати IP-адреси. Як будеш це реалізовувати?”

⸻

Хочеш — можу скласти для тебе повноцінний “Service Discovery Interview Pack”:
•	20+ питань
•	порівняльні таблиці
•	cheat sheet
•	mini-проекти для демонстрації знань (наприклад, Eureka + 2 мікросервіси)

Готовий зробити прямо зараз.

