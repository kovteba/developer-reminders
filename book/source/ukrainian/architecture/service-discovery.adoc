ifndef::imagesdir[:imagesdir: ../../imgs]

[#service-discovery]
=== Service Discovery

image::architecture/service-discovery.jpg[Service Discovery, align="center"]

[[service-discovery-definition]]*Service Discovery* — це механізм, який дозволяє автоматично знаходити та підключатися до сервісів у розподілених системах, таких як Docker Swarm або Kubernetes. Це особливо важливо в середовищах, де сервіси можуть динамічно змінювати IP-адресу, масштабуватися або переміщуватися між різними вузлами.

Наприклад, якщо у вас є сервіси _user-service_, _payment-service_ та _email-service_, і сервіс _payment-service_ хоче зв’язатися з _user-service_, то без Service Discovery потрібно вручну вказувати IP-адресу, наприклад: `http://192.168.0.15:8080`. Але якщо IP-адреса зміниться, _payment-service_ більше не зможе знайти _user-service_. Завдяки Service Discovery _payment-service_ може звернутися до _user-service_ за його логічною назвою: `http://user-service:8080`, і система автоматично знайде правильну IP-адресу та порт.

[[service-discovery-types]]
Основні типи *Service Discovery*:

* <<client-side-discovery,Client-side discovery>>;
* <<server-side-discovery,Server-side discovery>>;
* <<dns-based-discovery,DNS-based discovery>>;
* <<key-value-store-based-discovery,Key-Value Store-based discovery>>.


[[client-side-discovery]]
*Client-side discovery* (клієнтське виявлення) — це підхід до Service Discovery, при якому клієнт (тобто сервіс, який хоче знайти інший сервіс) самостійно звертається до сервісного реєстру, отримує список доступних інстансів потрібного сервісу і вибирає, до якого з них підключитися. У цьому випадку клієнт не покладається на проміжний проксі або шлюз для маршрутизації запитів. Прикладами систем, які використовують client-side discovery, є Netflix Eureka у поєднанні з Ribbon, а також клієнтські API Consul.

[[client-side-discovery-how-it-works]]
Як працює *Client-side discovery*:

1. Сервіс реєструє себе в сервісному реєстрі (наприклад, Eureka, Consul) при запуску, надаючи інформацію про своє розташування (IP-адресу, порт, метадані).
2. Коли клієнтський сервіс хоче звернутися до іншого сервісу, він запитує сервісний реєстр, щоб отримати список доступних інстансів цього сервісу.
3. Клієнт отримує список інстансів і використовує алгоритм балансування навантаження (наприклад, round-robin, random) для вибору одного з них.
4. Клієнт встановлює пряме з’єднання з обраним інстансом і виконує запит.
5. Якщо обраний інстанс недоступний, клієнт може повторити запит до сервісного реєстру, щоб отримати оновлений список інстансів і спробувати знову.

[source,java]
----
RestTemplate template = new RestTemplate();
String url = "http://user-service"; // логічне ім’я
----

Spring Cloud з Eureka + Ribbon автоматично знайде IP.

[[client-side-discovery-pros-and-cons]]
Переваги та недоліки *Client-side discovery*:

Переваги:

* Меньше навантаження на проміжні проксі, оскільки клієнт самостійно вибирає інстанс;
* Гнучкість у виборі алгоритмів балансування навантаження на стороні клієнта;
* Пряме з’єднання між клієнтом і сервісом, що може знизити затримки.

Недоліки:

* Кожен клієнт повинен мати логіку для взаємодії з сервісним реєстром, що ускладнює клієнтський код;
* Залежність від конкретного стека (наприклад, Eureka → Java only);
* Потрібно оновлювати всі клієнти при зміні логіки.

[[server-side-discovery]]
*Server-side discovery* (серверне виявлення) — це підхід до Service Discovery, при якому клієнтський сервіс звертається до проміжного проксі або шлюзу, а цей проміжний компонент самостійно виконує запит до сервісного реєстру та переспрямовує запит до потрібного інсансу сервісу. У цьому випадку клієнт не має прямого доступу до сервісного реєстру і не відповідає за вибір інстансу. Прикладами систем, які використовують server-side discovery, є Kubernetes (через kube-proxy і DNS), Envoy та Istio.

[[server-side-discovery-how-it-works]]
Як працює *Server-side discovery*:

1. Сервіс реєструє себе в сервісному реєстрі (наприклад, Kubernetes API Server, Consul) при запуску, надаючи інформацію про своє розташування (IP-адресу, порт, метадані).
2. Клієнтський сервіс звертається до проміжного проксі або шлюзу, вказуючи логічне ім’я потрібного сервісу (наприклад, через DNS-ім’я або URL).
3. Проксі або шлюз запитує сервісний реєстр, щоб отримати список доступних інстансів цього сервісу.
4. Проксі або шлюз використовує алгоритм балансування навантаження (наприклад, round-robin, random) для вибору одного з інстансів.
5. Проксі або шлюз встановлює з’єднання з обраним інстансом і переспрямовує запит від клієнта.
6. Якщо обраний інстанс недоступний, проксі або шлюз може повторити запит до сервісного реєстру, щоб отримати оновлений список інстансів і спробувати знову.

[source,java]
----
RestTemplate template = new RestTemplate();
String url = "http://gateway/user-service"; // через API Gateway
----

API Gateway (наприклад, Zuul, Kong) або сервісна сітка (наприклад, Istio) автоматично знайде IP.

[[server-side-discovery-pros-and-cons]]
Переваги та недоліки *Server-side discovery*:

Переваги:

* Спрощення клієнтського коду, оскільки клієнт не потребує логіки для взаємодії з сервісним реєстром;
* Централізоване управління маршрутизацією та балансуванням навантаження на стороні проксі або шлюзу;
* Легше впроваджувати політики безпеки, моніторинг і логування на рівні проксі або шлюзу.

Недоліки:

* Додаткове навантаження на проміжні проксі або шлюзи, що може стати вузьким місцем у системі;
* Затримки через додатковий рівень маршрутизації між клієнтом і сервісом;
* Залежність від надійності проміжного компонента (проксі або шлюзу).

[[dns-based-discovery]]
*DNS-based discovery* (виявлення на основі DNS) — це підхід до Service Discovery, при якому сервіси знаходять один одного за допомогою DNS-запитів. У цьому випадку кожен сервіс реєструється в DNS-системі з унікальним ім’ям, і клієнтські сервіси можуть звертатися до інших сервісів, використовуючи ці імена. DNS-система автоматично розв’язує ці імена в актуальні IP-адреси інстансів сервісів. Цей підхід широко використовується в Kubernetes (через CoreDNS) та Docker Swarm.

[[dns-based-discovery-how-it-works]]
Як працює *DNS-based discovery*:

1. Сервіс реєструє себе в DNS-системі при запуску, надаючи унікальне ім’я (наприклад, `user-service.default.svc.cluster.local` у Kubernetes).
2. Клієнтський сервіс звертається до іншого сервісу, використовуючи його DNS-ім’я.
3. DNS-система розв’язує це ім’я в актуальні IP-адреси інстансів сервісу.
4. Клієнт встановлює з’єднання з одним з отриманих IP-адрес і виконує запит.
5. Якщо інстанс недоступний, клієнт може повторити DNS-запит, щоб отримати оновлений список IP-адрес.

[source,java]
----
RestTemplate template = new RestTemplate();
String url = "http://user-service.default.svc.cluster.local"; // DNS-ім’я
----

Kubernetes (через CoreDNS) автоматично знайде IP.

[[dns-based-discovery-pros-and-cons]]
Переваги та недоліки *DNS-based discovery*:

Переваги:

* Широке використання та підтримка в багатьох системах (Kubernetes, Docker Swarm);
* Простота використання, оскільки DNS є стандартним механізмом у мережах;
* Автоматичне оновлення IP-адрес через TTL записів у DNS.

Недоліки:

* Затримки через DNS-запити, особливо якщо TTL високий і записи не оновлюються швидко;
* Обмежена гнучкість у виборі алгоритмів балансування навантаження (залежить від можливостей DNS-сервера);
* Можливі проблеми з кешуванням DNS на стороні клієнта, що може призводити до використання застарілих IP-адрес.

[[key-value-store-based-discovery]]
*Key-Value Store-based discovery* (виявлення на основі сховища ключ-значення) — це підхід до Service Discovery, при якому сервіси реєструють свої інстанси в розподіленому сховищі ключ-значення (наприклад, Consul, Etcd, Zookeeper). Клієнтські сервіси звертаються до цього сховища, щоб отримати інформацію про доступні інстанси інших сервісів. Цей підхід забезпечує високу доступність і консистентність даних про сервіси.

[[key-value-store-based-discovery-how-it-works]]
Як працює *Key-Value Store-based discovery*:

1. Сервіс реєструє себе в сховищі ключ-значення при запуску, створюючи запис з унікальним ключем (наприклад, `services/user-service/instance-id`) і значенням, що містить інформацію про розташування (IP-адресу, порт, метадані).
2. Клієнтський сервіс звертається до сховища ключ-значення, щоб отримати список доступних інстансів потрібного сервісу.
3. Клієнт отримує список інстансів і використовує алгоритм балансування навантаження (наприклад, round-robin, random) для вибору одного з них.
4. Клієнт встановлює пряме з’єднання з обраним інстансом і виконує запит.
5. Якщо обраний інстанс недоступний, клієнт може повторити запит до сховища ключ-значення, щоб отримати оновлений список інстансів і спробувати знову.

[source,java]
----
RestTemplate template = new RestTemplate();
String url = "http://user-service"; // логічне ім’я
----

Consul API або інший клієнт автоматично знайде IP.

[[key-value-store-based-discovery-pros-and-cons]]
Переваги та недоліки *Key-Value Store-based discovery*:

Переваги:

* Висока доступність і консистентність даних про сервіси завдяки розподіленій природі сховищ ключ-значення;
* Гнучкість у виборі алгоритмів балансування навантаження на стороні клієнта;
* Підтримка складних сценаріїв, таких як health checks і метадані сервісів.

Недоліки:

* Додаткова складність у налаштуванні та управлінні сховищем ключ-значення;
* Залежність від надійності та продуктивності сховища ключ-значення;
* Потрібно оновлювати всі клієнти при зміні логіки взаємодії зі сховищем.

[[service-discovery-types-comparison]]
|====
|Критерій                   |Client-side|Server-side        |DNS-based              |KV Store-based
|Складність на клієнті      |Висока     |Низька             |Низька                 |Висока
|Потрібна підтримка проксі  |Ні         |Так                |Ні                     |Ні
|Балансування трафіку       |Гнучке     |Централізоване     |Базове (round-robin)   |Вручну або зовнішнє
|Підтримка мов / стеків     |Обмежена   |Будь-яка           |Будь-яка               |Через SDK/API
|Залежність від бібліотек   |Є          |Відсутня           |Відсутня               |Є (наприклад, gRPC+etcd)
|Контроль з боку DevOps     |Складно    |Повний контроль    |Обмежено               |Повний контроль
|Продуктивність             |Висока     |Нижча через проксі |Висока                 |Висока (без проксі)
|====

Service Discovery відповідає двом з 2 властивостей <<cap-theory,CAP-теорії>>:

1. Бути доступними (A), щоб клієнти могли завжди знайти потрібний сервіс.
2. Бути узгодженими (C), щоб уникнути фальшивих або застарілих записів.

Але при мережевому розділенні (P), доводиться обирати:

* *Consul*/*Etcd*/*Zookeeper* —> *CP системи*: пріоритет консистентності. Краще зупинити запис, ніж допустити помилкову інформацію.
* **DNS-based discovery** —> *AP системи*: завжди дає відповідь, але може бути застарілою (через TTL, кешування).

[[service-discovery-where-used]]
Де використовується *Service Discovery*:

* *Docker Swarm*: має вбудований механізм Service Discovery, що дозволяє сервісам знаходити один одного за іменами;
* *Kubernetes*: використовує вбудовану DNS-систему (CoreDNS) для автоматичного розв’язання імен сервісів;
* *Consul*, *Etcd*, *Zookeeper*: зовнішні системи Service Discovery, які можуть бути інтегровані з Docker, Kubernetes або іншими платформами;
* *AWS Cloud Map*, *Google Cloud Service Directory*: хмарні сервіси для управління реєстрацією та виявленням сервісів у масштабованих інфраструктурах.

[[service-discovery-what-for]]
Що дає *Service Discovery*:

* *Автоматизація*: зменшує потребу в ручному налаштуванні мережевих адрес;
* *Балансування навантаження*: деякі системи Service Discovery можуть автоматично розподіляти трафік між кількома інстансами сервісу;
* *Failover*: забезпечує автоматичне перенаправлення трафіку у випадку відмови одного з інстансів сервісу;
* *Горизонтальне масштабування*: дозволяє легко додавати або видаляти інстанси сервісу без необхідності змінювати конфігурацію клієнтів.

[[service-discovery-tools]]
Приклади інструментів *Service Discovery*:

* *Docker Swarm*: має вбудований механізм Service Discovery на основі DNS;
* *Kubernetes DNS (CoreDNS)*: вбудована DNS-система для автоматичного розв’язання імен сервісів у кластері;
* *Consul*: потужний інструмент для Service Discovery, health-check-ів та централізованого зберігання конфігурацій;
* *etcd*: розподілене key-value сховище, що використовується Kubernetes для зберігання конфігурації кластера, включно з даними для Service Discovery;
* *Zookeeper*: використовується для координації розподілених систем і як механізм Service Discovery (наприклад, у Kafka, Hadoop);
* *Eureka*: сервісний реєстр, який широко використовується в екосистемі Spring Cloud.

[[service-discovery-main-components]]
Головні компоненти *Service Discovery*:

* *Реєстратор сервісів (Service Registrar)*: компонент, який відповідає за реєстрацію нових інстансів сервісу в реєстрі та їх видалення у разі зупинки або збою;
* *Сервіс (Service)*: застосунок або мікросервіс, який реєструється в системі Service Discovery;
* *Клієнт Service Discovery*: компонент (або бібліотека), який дозволяє сервісам знаходити інші сервіси за їх логічними іменами;
* *Health Checks*: механізми перевірки стану інстансів сервісів, які гарантують, що клієнти взаємодіють лише з працездатними інстансами;
* *Інтерфейс доступу (DNS або API)*: спосіб, через який клієнти отримують інформацію про доступні сервіси (наприклад, через DNS-імена або REST/gRPC API).

// TODO Service Discovery
// ✅ 4. Service Discovery vs API Gateway vs Service Mesh
// Компонент	Основна функція
// Service Discovery	Знаходить інстанси сервісів
// API Gateway	Виступає єдиною точкою входу для клієнтів
// Service Mesh	Контролює трафік між сервісами на рівні L7 (часто в тандемі з discovery)
//
// ✅ 5. Failure Scenarios & Resilience
// •	Що буде, якщо зникне весь кластер Consul?
// •	Як Kubernetes відновлює DNS CoreDNS pod?
// •	Як будувати circuit breakers, retries, timeouts при використанні Service Discovery?
//
// ✅ 6. Роль DNS у Service Discovery
// •	Чим DNS-базований discovery відрізняється від API?
// •	Що таке SRV-записи? Як працює dnsRoundRobin?
// •	TTL-залежна кешованість: потенційна проблема в stale-записах
//
// ✅ 7. Безпека Discovery
// •	Хто може реєструвати сервіси?
// •	Може зловмисник зареєструвати фейковий auth-service?
// •	Як захистити доступ до Registry? (mTLS, ACL, JWT)
//
// ✅ 8. Інструменти з досвідом використання
// Інструмент	Що треба знати
// Consul	ACL, DNS, health checks, sync modes
// Eureka	Self-preservation mode, client cache
// Kubernetes	CoreDNS, headless services, SRV-записи
// Zookeeper	ZNode, ephemeral nodes, leader election
//
// ✅ 9. Класичні питання з інтерв’ю
// •	Поясни різницю між client-side і server-side discovery.
// •	Як ти реалізуєш zero-downtime deployment, якщо IP змінюється?
// •	Що буде, якщо один з інстансів сервісу не працює, але ще зареєстрований?
// •	Чим Kubernetes service discovery відрізняється від Eureka/Consul?





