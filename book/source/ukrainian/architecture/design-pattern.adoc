ifndef::imagesdir[:imagesdir: ../../imgs]

[#design-pattern]
=== Design Patterns

image::architecture/designpattern/design-pattern.jpg[Design Patterns, align="center"]

[[design-patterns-definition]]*Design Patterns* — це повторювані рішення поширених проблем у розробці програмного забезпечення. Вони є шаблонами або каркасами, які можна адаптувати до конкретних ситуацій, допомагаючи розробникам створювати більш ефективний, підтримуваний і масштабований код.

[[design-pattern-categories]]
Основними категоріями патернів проєктування є:

* <<design-pattern-creational-patterns,*Породжуючі патерни (Creational Patterns)*>> — зосереджені на процесі створення об'єктів, забезпечуючи гнучкість і контроль над тим, як об'єкти створюються;
* <<design-pattern-structural-patterns,*Структурні патерни (Structural Patterns)*>> — спрямовані на організацію класів і об'єктів у більші структури, полегшуючи роботу з ними;
* <<design-pattern-behavioral-patterns,*Поведінкові патерни (Behavioral Patterns)*>> — зосереджені на взаємодії між об'єктами і розподілі відповідальностей.

[[design-pattern-creational-patterns]]
До породжувальних патернів належать:

* <<design-pattern-factory-method,*Factory Method*>> — визначає інтерфейс для створення об'єктів, але дозволяє підкласам вирішувати, який клас інстанціювати;
* <<design-patternabstract-factory,*Abstract Factory*>> — надає інтерфейс для створення сімейств пов'язаних або залежних об'єктів без вказівки їх конкретних класів;
* <<design-pattern-builder,*Builder*>> — відокремлює конструювання складного об'єкта від його представлення, дозволяючи створювати різні представлення об'єкта;
* <<design-pattern-prototype,*Prototype*>> — дозволяє створювати нові об'єкти шляхом копіювання існуючих, що особливо корисно для складних об'єктів;
* <<design-pattern-singleton,*Singleton*>> — забезпечує існування лише одного екземпляра класу і надає глобальну точку доступу до нього.

[[design-pattern-structural-patterns]]
До структурних патернів належать:

* <<design-pattern-adapter,*Adapter*>> — дозволяє об'єктам з несумісними інтерфейсами працювати разом, перетворюючи інтерфейс одного об'єкта в інтерфейс, який очікує інший об'єкт;
* <<design-pattern-bridge,*Bridge*>> — розділяє абстракцію від її реалізації, дозволяючи їм змінюватися незалежно один від одного;
* <<design-pattern-composite,*Composite*>> — дозволяє групувати об'єкти в деревоподібну структуру для представлення ієрархій "частина-ціле", забезпечуючи однаковий інтерфейс для роботи з окремими об'єктами і їхніми композиціями;
* <<design-pattern-decorator,*Decorator*>> — динамічно додає нові поведінкові можливості об'єктам, обгортаючи їх у додаткові класи;
* <<design-pattern-facade,*Facade*>> — надає спрощений інтерфейс до складної підсистеми, полегшуючи її використання;
* <<design-pattern-flyweight,*Flyweight*>> — зменшує кількість створюваних об'єктів шляхом спільного використання вже існуючих, що особливо корисно для великих кількостей схожих об'єктів;
* <<design-pattern-proxy,*Proxy*>> — надає замінник або сурогат для іншого об'єкта, контролюючи доступ до нього.

[[design-pattern-behavioral-patterns]]
До поведінкових патернів належать:

* *<<design-pattern-chain-of-responsibility,Chain of Responsibility*>> — дозволяє передавати запити по ланцюжку об'єктів, поки один з них не обробить запит, що знижує зв'язність між відправником і отримувачем запиту;
* <<design-pattern-command,*Command*>> — інкапсулює запит як об'єкт, дозволяючи параметризувати клієнтів різними запитами, чергувати або журналювати їх, а також підтримувати операції скасування;
* <<design-pattern-iterator,*Iterator*>> — надає спосіб послідовного доступу до елементів агрегованого об'єкта без розкриття його внутрішньої структури;
* <<design-pattern-mediator,*Mediator*>> — визначає об'єкт, який інкапсулює спосіб взаємодії множини об'єктів, сприяючи слабкому зв'язку між ними;
* <<design-pattern-memento,*Memento*>> — дозволяє зберігати і відновлювати попередній стан об'єкта без порушення інкапсуляції;
* <<design-pattern-observer,*Observer*>> — визначає залежність "один до багатьох" між об'єктами, так що при зміні стану одного об'єкта всі залежні від нього об'єкти автоматично оновлюються;
* <<design-pattern-state,*State*>> — дозволяє об'єкту змінювати свою поведінку при зміні його внутрішнього стану, ніби об'єкт змінює свій клас;
* <<design-pattern-strategy,*Strategy*>> — визначає сімейство алгоритмів, інкапсулює кожен з них і робить їх взаємозамінними, дозволяючи вибирати алгоритм під час виконання;
* <<design-pattern-template-method,*Template Method*>> — визначає скелет алгоритму в методі, відкладаючи деякі кроки на підкласи, дозволяючи їм змінювати певні частини алгоритму без зміни його структури;
* <<design-pattern-visitor,*Visitor*>> — дозволяє додавати нові операції до об'єктів без зміни їх класів, розділяючи алгоритм від структури об'єктів.

include::./designpattern/creational/design-pattern-factory-method.adoc[]

include::./designpattern/creational/design-pattern-abstract-factory.adoc[]

include::./designpattern/creational/design-pattern-builder.adoc[]

include::./designpattern/creational/design-pattern-prototype.adoc[]

include::./designpattern/creational/design-pattern-singelton.adoc[]

include::./designpattern/structural/design-pattern-adapter.adoc[]

include::./designpattern/structural/design-pattern-bridge.adoc[]

include::./designpattern/structural/design-pattern-composite.adoc[]

include::./designpattern/structural/design-pattern-decorator.adoc[]

include::./designpattern/structural/design-pattern-facade.adoc[]

include::./designpattern/structural/design-pattern-flyweight.adoc[]

include::./designpattern/structural/design-pattern-proxy.adoc[]

include::./designpattern/behavioral/design-pattern-chain-of-responsibility.adoc[]

include::./designpattern/behavioral/design-pattern-command.adoc[]

include::./designpattern/behavioral/design-pattern-iterator.adoc[]

include::./designpattern/behavioral/design-pattern-mediator.adoc[]

include::./designpattern/behavioral/design-pattern-memento.adoc[]

include::./designpattern/behavioral/design-pattern-observer.adoc[]

include::./designpattern/behavioral/design-pattern-state.adoc[]

include::./designpattern/behavioral/design-pattern-strategy.adoc[]

include::./designpattern/behavioral/design-pattern-template-method.adoc[]

include::./designpattern/behavioral/design-pattern-visitor.adoc[]


// Decorator и Proxy мають схожу структуру, але різні цілі використання. Decorator додає поведінку об'єкту динамічно, тоді як Proxy контролює доступ до об'єкту.
