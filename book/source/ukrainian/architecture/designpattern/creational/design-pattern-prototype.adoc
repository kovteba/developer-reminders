ifndef::imagesdir[:imagesdir: ../../../../imgs/]
ifndef::prototypeexampledir[:prototypeexampledir: ../../../../../../examples/design-patterns/prototype/src/main/java/kovteba]

[#design-pattern-prototype]
==== Prototype

image::architecture/designpattern/creational/design-patterns-prototype.jpg[Prototype, align="center"]

[[design-pattern-prototype-definition]]*Prototype* — це патерн проєктування, який належить до категорії <<design-pattern-creational-patterns,породжувальних патернів>> і дає змогу створювати нові об’єкти шляхом копіювання існуючих екземплярів, зберігаючи їх внутрішній стан. На відміну від інших патернів створення, Prototype дозволяє обійти складні або дорогі операції ініціалізації, адже замість створення об’єкта з нуля достатньо скопіювати вже існуючий екземпляр. [[design-pattern-prototype-main-idea]]Основна ідея полягає у тому, щоб забезпечити механізм *поверхневого (shallow)* або *глибокого (deep)* копіювання об’єктів, не покладаючись на конкретні класи або їхні конструктори.

[[design-pattern-prototype-purpose]]Prototype особливо корисний тоді, коли створення нового об’єкта є ресурсомістким — наприклад, вимагає доступу до файлової системи, мережевих операцій, баз даних або дорогих обчислень. Клонування ж дає змогу швидко отримати новий екземпляр з ідентичними параметрами.

[[design-pattern-prototype-difference-from-copy]]На відміну від простого копіювання через конструктор, Prototype приховує логіку створення копій і уніфікує її через спільний інтерфейс. Завдяки цьому клієнтський код працює з об’єктами як із “чорними скриньками”, не знаючи деталей їхньої внутрішньої структури. Це сприяє слабкому зв’язуванню й відповідає принципам SOLID (зокрема <<solid-ocp,OCP>> і <<solid-srp,SRP>>).

[[design-pattern-prototype-shallow-vs-deep]]Важливо розрізняти два типи копіювання:

* *Шallow copy* — копіює лише сам об’єкт, але не його вкладені структури.
* *Deep copy* — створює повністю незалежну копію разом із усіма вкладеними об’єктами, щоб зміни в одному екземплярі не впливали на інший.

[[design-pattern-prototype-usage]]Патерн Prototype часто використовується:

* У системах, де потрібно створювати багато схожих об’єктів;
* У складних конфігураціях (наприклад, клонування UI-компонентів);
* В ігрових рушіях (клонування ігрових сутностей);
* У фреймворках, що кешують шаблони, конфігурації або метадані;
* У Java — у багатьох бібліотеках, де використовуються шаблонні структури або копіювання дерев об’єктів.

[[design-pattern-prototype-example]]Нижче наведемо приклад реалізації Prototype. Спочатку визначимо інтерфейс Prototype, що оголошує метод `copy()`:

[source,java]
----
include::{prototypeexampledir}/Prototype.java[tags=Prototype]
----

Створюємо клас `Metadata`, який буде вкладеною структурою в основному об’єкті:

[source,java]
----
include::{prototypeexampledir}/Metadata.java[tags=Metadata]
----

Визначаємо клас `Document`, що реалізує интерфейс Prototype і підтримує глибоке копіювання:

[source,java]
----
include::{prototypeexampledir}/Document.java[tags=Document]
----

Далі продемонструємо процес клонування в окремому класі:

[source,java]
----
include::{prototypeexampledir}/PrototypeDemo.java[tags=PrototypeDemo]
----

[[design-pattern-prototype-benefits]]Основні переваги Prototype:

* Мінімізує залежність від конструкторів;
* Дозволяє клонувати об’єкти з великою кількістю параметрів;
* Забезпечує швидке створення притаманних структур;
* Підтримує deep copy для складних об’єктів;
* Спрощує роботу з динамічними структурами та шаблонами.

[[design-pattern-prototype-summary]]У підсумку, *Prototype* — це потужний інструмент управління створенням об’єктів у системах, де копіювання є частим або складним процесом. Він робить архітектуру гнучкішою, прискорює ініціалізацію, зменшує дублювання коду та забезпечує стабільність поведінки об’єктів у різних контекстах виконання.
