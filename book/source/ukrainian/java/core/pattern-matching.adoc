ifndef::imagesdir[:imagesdir: ../../../imgs/]
ifndef::patternmatchingdir[:patternmatchingdir: ../../../../../examples/java/src/main/java/kovteba/java21/patternmatchings]
ifndef::patternmatchingtestdir[:patternmatchingtestdir: ../../../../../examples/java/src/test/java/kovteba/patternmatchings]

[#java-pattern-matching]
==== Pattern Matching
[[java-pattern-matching-definition]]Pattern Matching (Зіставлення зі зразком) — це декларативна парадигма програмування, де ми описуємо структуру, яку очікуємо побачити в даних, і якщо дані відповідають цій структурі, ми автоматично отримуємо доступ до їхніх частин. Уявіть це як «фільтр-сортувальник» для пошти: ви не просто кажете «перевір кожен конверт», ви кажете: «якщо це конверт з червоною печаткою — дістань з нього лист і поклади на стіл; якщо це бандероль — розпакуй її та віддай мені вміст».

.В основі Pattern Matching лежать три кити:
1. Зіставлення (Matching): Перевірка об'єкта на відповідність певній формі (тип, кількість полів, конкретні значення);
2. Деструктуризація (Destructuring): «Розбирання» об'єкта на частини. Якщо ми знаємо, що перед нами об'єкт Point, ми одразу витягуємо його координати x та y;
3. Зв'язування (Binding): Автоматичне створення локальних змінних для цих частин, щоб їх можна було використовувати в блоці коду.

[[java-pattern-matching-main-goals]]
.Головне призначення (Філософія):
1. Перехід від Імперативного до Декларативного стилю. Замість того, щоб писати покрокову інструкцію: "Перевір, чи це список. Якщо так, перевір, чи він має два елементи. Якщо має, візьми перший і назви його 'a', а другий — 'b'", ви просто кажете: "Дай мені [a, b]". Ви описуєте результат, а не процес.
2. Безпека типів (Type Safety). Pattern Matching робить код надійнішим. У багатьох мовах (і в Java зокрема) компілятор може перевірити вичерпність (exhaustiveness). Якщо ви описали обробку лише для Circle та Square, а у вас є ще Triangle, компілятор видасть помилку ще до запуску програми.
3. Робота з "сирими" даними. Це ідеальний інструмент для обробки форматів на кшталт JSON, XML або складних деревоподібних структур (наприклад, абстрактного синтаксичного дерева — AST), де дані — це просто вкладені контейнери.

[[java-pattern-matching-main-properties]]
.Основні властивості:
* Рекурсивність: Паттерни можуть бути вкладеними. Ви можете шукати «список, де перший елемент — це інший список, що містить число 42»;
* Охоронці (Guards): Можливість додати логічну умову до структури. «Знайди мені прямокутник, якщо його площа більша за 100»;
* Відсутність побічних ефектів: Pattern Matching зазвичай лише читає дані, не змінюючи вихідний об'єкт.

[[java-pattern-matching-comparison]]
Порівняння концепцій:
|===
|Концепція|Як це виглядає без Pattern Matching|З Pattern Matching
|Доступ до даних|Виклик getter-ів (obj.getAtribut())|Опис структури (Point(x, y))
|Перевірка типу|Складні if-else та instanceof|Лаконічний перелік case
|Логіка|Фокус на тому, ЯК дістати дані|Фокус на тому, ЩО це за дані
|===

[[java-pattern-matching-why-important]]Світ програмування рухається в бік обробки великих обсягів даних. Код стає менш орієнтованим на «дію» (методи) і більш орієнтованим на «дані» (records, DTO). Pattern Matching — це міст, який дозволяє обробляти ці дані швидко, безпечно і без зайвого візуального шуму.

include::../java16/pattern-matching-java-16.adoc[]

include::../java21/pattern-matching-java-21.adoc[]
