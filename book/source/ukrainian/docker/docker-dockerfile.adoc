ifndef::imagesdir[:imagesdir: source/imgs/]

[#docker-dockerfile]
=== Dockerfile

image::docker/docker-dockerfile.jpg[DockerFile, align="center"]

[[docker-dockerfile-definition]]*dockerfile* — це текстовий файл, який містить набір інструкцій для створення Docker-образу. Він визначає, як збирати образ, які команди виконувати, які файли копіювати, які порти відкривати тощо. Dockerfile використовується командою `docker build` для створення нового образу на основі вказаних інструкцій.

[[docker-dockerfile-instructions]]Основні головні інструкції в Dockerfile:

* <<docker-dockerfile-from,`FROM`>>
* <<docker-dockerfile-run,`RUN`>>
* <<docker-dockerfile-cmd,`CMD`>>
* <<docker-dockerfile-entrypoint,`ENTRYPOINT`>>
* <<docker-dockerfile-copy,`COPY`>>
* <<docker-dockerfile-add,`ADD`>>
* <<docker-dockerfile-workdir,`WORKDIR`>>
* <<docker-dockerfile-expose,`EXPOSE`>>
* <<docker-dockerfile-env,`ENV`>>
* <<docker-dockerfile-arg,`ARG`>>
* <<docker-dockerfile-user,`USER`>>
* <<docker-dockerfile-volume,`VOLUME`>>
* <<docker-dockerfile-label,`LABEL`>>
* <<docker-dockerfile-healtcheck,`HEALTHCHECK`>>
* <<docker-dockerfile-shell,`SHELL`>>

[[docker-dockerfile-from]]
.`FROM`
[[docker-dockerfile-from-definition]]*`FROM`* — це перша й обов’язкова інструкція у більшості Dockerfile. Вона визначає базовий образ, на основі якого буде створено новий Docker-образ. Головні особливості:

* Вказує базовий образ, з якого починається збірка нового образу;
* Може використовуватися декілька разів для multi-stage builds;
* Підтримує різні формати, такі як `FROM <image>[:<tag>]` або `FROM <image>@<digest>` для більшої стабільності збірки;
* Підтримує вказівку архітектури та тегу, наприклад `FROM --platform=linux/amd64 ubuntu:20.04`;
* Підтримує вказівку `AS <name>` для іменування етапу в multi-stage builds.

[[docker-dockerfile-from-usage]]Головне призначення `FROM` — це визначення базового образу, на якому буде побудований новий образ. В multi-stage builds `FROM` може використовуватися декілька разів для створення різних етапів збірки:

[source,dockerfile]
----
FROM ubuntu AS builder
RUN apt-get update && apt-get install -y build-essential
COPY . /app
WORKDIR /app
RUN make

FROM alpine AS runtime
COPY --from=builder /app/myapp /usr/local/bin/myapp
CMD ["/usr/local/bin/myapp"]
----

У цьому прикладі перший `FROM` створює етап збірки, де встановлюються залежності та компілюється додаток. Другий `FROM` створює етап виконання, де копіюється скомпільований додаток з попереднього етапу.

Якщо `FROM` не вказано, Docker не зможе створити образ, оскільки не буде знати, з якого базового образу починати збірку. Це призведе до помилки (Dockerfile parse error: No FROM instruction found) під час виконання команди `docker build`.

Є особливий випадок, коли `FROM` не вказується, це використання `scratch` як базового образу. `scratch` — це порожній образ, який використовується для створення мінімальних образів без операційної системи. Наприклад:

[source,dockerfile]
----
FROM scratch
COPY myapp /myapp
CMD ["/myapp"]
----

`scratch` використовується:

* Коли потрібно створити дуже легкий образ без операційної системи;
* Коли додаток не потребує жодних бібліотек або залежностей, окрім самого виконуваного файлу;
* Для створення образів на основі статично скомпільованих додатків, таких як Go або Rust.

Особливостями `scratch` є:

* Він не містить жодних файлів або директорій, тому всі команди, такі як `RUN`, `COPY`, `ADD`, будуть створювати нові файли в порожньому образі;
* Не підтримує жодних операцій з файловою системою, оскільки це порожній образ;
* Не має shелл або інших утиліт, тому не можна виконувати команди, які потребують shell (наприклад, `RUN ls` не спрацює).

В `FROM` можна вказати архітектуру, на якій буде створено образ. Це особливо корисно для multi-stage builds, де різні етапи можуть мати різні архітектури. Наприклад:

[source,dockerfile]
----
FROM --platform=linux/arm64 ubuntu:20.04 AS builder
RUN apt-get update && apt-get install -y build-essential
COPY . /app
WORKDIR /app
RUN make
CMD ["/app/myapp"]
----

Оптімальними базовими образами для `FROM` є:

* `alpine` — легкий образ (~5МВ) з базовою операційною системою, який містить лише необхідні утиліти;
* `ubuntu` — повноцінний образ з Ubuntu, який містить всі стандартні утиліти та бібліотеки, розмір ~30-60МВ;
* `debian`/`slim` — повноцінний образ з Debian, який також містить всі стандартні утиліти та бібліотеки, розмір ~20МВ;
* `scratch` — порожній образ, який використовується для створення мінімальних образів без операційної системи, розмір ~0МВ.

[[docker-dockerfile-from-best-practices]]Best Practices для `FROM`:

* Використовуй легкі базові образи, такі як `alpine` або `scratch`, якщо це можливо;
* Уникай використання важких базових образів, таких як `ubuntu` або `debian`, якщо не потрібні всі їхні утиліти;
* Використовуй `FROM` з тегами, щоб уникнути проблем з несумісністю версій (наприклад, `FROM ubuntu:20.04` замість `FROM ubuntu`);
* Уникай використання `latest` тегів, оскільки це може призвести до непередбачуваних змін у збірці;
* Використовуй `FROM` з `AS <name>` для іменування етапів у multi-stage builds, щоб зробити Dockerfile більш читабельним;
* Уникай використання `FROM scratch`, якщо не впевнений, що додаток не потребує жодних бібліотек або утиліт;
* Використовуй `FROM` з `--platform` для вказівки архітектури, якщо потрібно створити образ для різних платформ (наприклад, `FROM --platform=linux/amd64 ubuntu:20.04`).

[[docker-dockerfile-run]]
.`RUN`
[[docker-dockerfile-run-definition]]*`RUN`* — виконує команду на етапі збірки образу. Результат її виконання зберігається як шар (layer) в Docker-образі. [[docker-dockerfile-run-usage]]Для кожної інструкції `RUN` створюється новий шар, який містить зміни, внесені цією командою. Це дозволяє Docker використовувати кеш для оптимізації збірки образів. Чим більше шарів тім більше образ, тому краще об'єднувати команди в один `RUN`, використовуючи `&&` для зменшення кількості шарів. Наприклад:

[source,dockerfile]
----
RUN apt-get update
RUN apt-get install -y curl
RUN rm -rf /var/lib/apt/lists/*
----

Для кождної інструкції `RUN` створюється новий шар, що може призвести до збільшення розміру образу. Краще об'єднати ці команди в один `RUN`, щоб зменшити кількість шарів:

[source,dockerfile]
----
RUN apt-get update && \
    apt-get install -y curl && \
    rm -rf /var/lib/apt/lists/*
----

Зараз Docker створить лише один шар, який міститиме всі зміни, внесені цими командами. Це зменшує розмір образу та прискорює збірку. Docker кешує результати кожної інструкції `RUN`, якщо команда не змінилася, Docker використовує кеш для цього шару. Якщо команда не змінилась але ми хочемо, щоб Docker знову виконав її, можна використовувати `--no-cache` при збірці образу:

[source,shell]
----
docker build --no-cache -t myimage .
----

Також для мінімізації розміру образу треба використовувати `apt-get clean && rm -rf /var/lib/apt/lists/*` після встановлення пакетів, щоб видалити тимчасові файли, які не потрібні в кінцевому образі. Наприклад:

[source,dockerfile]
----
RUN apt-get update && \
    apt-get install -y curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
----

Також гарною практикою є створення каталогу с певними правами доступу, щоб уникнути проблем з правами доступу до файлів в контейнері. Наприклад:

[source,dockerfile]
----
RUN mkdir -p /app && \
    chown -R username:usergroup /app
----

Що створює каталог `/app` з правами доступу для користувача `username` та групи `usergroup`. Це дозволяє уникнути проблем з правами доступу до файлів в контейнері, якщо додаток працює від імені цього користувача.

[[docker-dockerfile-run-best-practices]]Best Practices для `RUN`:

* Використовуй `&&` для об'єднання команд в один `RUN`, щоб зменшити кількість шарів;
* Не додавай секрети або конфіденційну інформацію в `RUN`, оскільки вони залишаться в історії образу;
* Використовуй `--no-cache` при збірці, якщо потрібно примусово виконати команду `RUN`, навіть якщо вона не змінилася;
* Використовуй `apt-get clean && rm -rf /var/lib/apt/lists/*` після встановлення пакетів, щоб зменшити розмір образу;
* Створюй каталоги з певними правами доступу, щоб уникнути проблем з правами доступу до файлів в контейнері.

[[docker-dockerfile-cmd]]
.`CMD`
[[docker-dockerfile-cmd-definition]]*CMD* — це інструкція Dockerfile, яка визначає команду за замовчуванням, яку Docker виконає при запуску контейнера, якщо не вказано інше під час запуску.

[source,dockerfile]
----
CMD ["executable", "param1", "param2"]
----

Ця команда не буде виконана під час збірки образу, а лише при запуску контейнера (`docker run`). Якщо вказано декілька аргументів, вони будуть передані як список. Може бути тільки одна інструкція CMD в Dockerfile, якщо їх декілька, то буде використана остання. Така інструкція не потребує <<docker-dockerfile-entrypoint,`ENTRYPOINT`>>. Не запускається через shell, тому не потрібно використовувати `sh -c` або `bash -c`. Якщо потрібно виконати команду через shell, використовуйте `ENTRYPOINT` з `CMD` для аргументів, або наступний формат (але це застарілий варіант):

[source,dockerfile]
----
CMD executable param1 param2
----

Наприклад:

[source,dockerfile]
----
CMD nginx -g "daemon off;"
----

Що єквівалентно до:

[source,dockerfile]
----
CMD ["/bin/sh", "-c", "nginx -g 'daemon off;'"]
----

[[docker-dockerfile-cmd-usage]]Головне призначення `CMD` — це визначення команди, яка буде виконана при запуску контейнера. Інструкція CMD у Dockerfile використовується Docker’ом під час запуску контейнера, а не під час збірки образу. Вона задає команду за замовчуванням, яка буде виконана, якщо користувач не вкаже свою. Наприклад є Dockerfile:

[source,dockerfile]
----
FROM alpine
CMD ["echo", "Hello, World!"]
----

І при запуску користувач вказує свою команду, наприклад "ls- la":

[source,shell]
----
docker run myimage echo "ls -la"
----

У цьому випадку команда `CMD` буде ігноруватися, і буде виконана команда користувача. Якщо ж користувач не вказує свою команду, то буде виконана команда з `CMD`, тобто `echo "Hello, World!"`. Якщо `CMD` використовується разом з `ENTRYPOINT`, то `CMD` буде передаватися як аргументи до `ENTRYPOINT`. Наприклад:

[source,dockerfile]
----
FROM alpine
ENTRYPOINT ["ping"]
CMD ["google.com"]
----

[source,shell]
----
docker run myimage
# → ping google.com

docker run myimage yahoo.com
# → ping yahoo.com
----

Також для того, щоб перевизначити `CMD` у docker-compose файлі, можна використовувати `command`:

[source,yaml]
----
version: '3'

services:
  myservice:
    image: myimage
    command: ["echo", "Hello from docker-compose!"]
----

Якщо не вказано `command`, то буде виконана команда з `CMD` в Dockerfile.

У Kubernetes, `CMD` може бути перевизначено в `Deployment` або `Pod` через поле `command`. Наприклад:

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
        - name: mycontainer
          image: myimage
          command: ["ping", "localhost"]  # Перезаписує ENTRYPOINT/CMD, що єквівалентно ENTRYPOINT ["echo", "Hello from Kubernetes!"]
          args: ["google.com"]            # Аргументи для команди, що єквівалентно CMD ["google.com"]
----

//TODO CMD в multi-stage builds

[[docker-dockerfile-cmd-summary]]
Головне про CMD:

* Використовується для визначення команди за замовчуванням, яка буде виконана при запуску контейнера;
* Якщо не вказано, то буде виконана команда з `CMD`;
* Якщо користувач вказує свою команду при запуску, то команда з `CMD` буде ігноруватися;
* Якщо використовується разом з `ENTRYPOINT`, то `CMD` буде передаватися як аргументи до `ENTRYPOINT`;
* Якщо в Dockerfile є декілька `CMD`, то буде використана остання команда;
* `CMD` не виконується якщо вказана інша команда при запуску контейнера або якщо використовується `--entrypoint`, тоді `CMD` буде ігноруватися (якщо не використовується як аргумент).

[[docker-dockerfile-cmd-best-practices]]
//TODO `CMD` Best Practices:

// * ✅ Використовуй exec form (CMD ["..."]) для кращої обробки сигналів.
// * ⚠️ Не використовуй одночасно CMD і ENTRYPOINT у shell-формі — це складно дебажити.
// * ✅ Використовуй CMD тільки для значень за замовчуванням, які можна легко замінити.
// * ❌ Не зловживай CMD для запуску складних скриптів — краще використовувати ENTRYPOINT + CMD.

[[docker-dockerfile-entrypoint]]
.`ENTRYPOINT`
[[docker-dockerfile-entrypoint-definition]]*`ENTRYPOINT`* — визначає основну команду, яку Docker завжди виконає, коли запускається контейнер. На відміну від <<docker-dockerfile-cmd,`CMD`>>, вона не перезаписується аргументами docker run, якщо явно не використати --entrypoint. Головною метою `ENTRYPOINT` є запусити процес який  має стартувати разом з контейнером. Приймати параметри від <<docker-dockerfile-cmd,`CMD`>> або аргументів командного рядка (`docker run`).

[[docker-dockerfile-entrypoint-usage]]Головною метою `ENTRYPOINT` є запуск процесу, який має стартувати разом з контейнером в незалежності від того, чи вказані додаткові аргументи при запуску контейнера. Це дозволяє створити контейнер, який завжди виконує певну задачу, наприклад, запуск веб-сервера або бази даних. Далі наведемо приклади використання `ENTRYPOINT`, першим прикладом є простий запуск Nginx сервера(наприклад):

[source,dockerfile]
----
FROM nginx
ENTRYPOINT ["nginx", "-g", "daemon off;"]
----

Також `ENTRYPOINT` може використовуватись для запуску та передачі аргументів в shell-скрипт, наприклад:

[source,dockerfile]
----
FROM alpine
COPY start.sh /usr/local/bin/start.sh
ENTRYPOINT ["/usr/local/bin/start.sh"]
----

[source,shell]
----
#!/bin/sh
echo "Запуск з аргументами: $@"
exec "$@"
----

При запуску контейнера з таким `ENTRYPOINT`, ви можете передати додаткові аргументи, які будуть доступні в скрипті `start.sh` через `$@`. Наприклад:

[source,shell]
----
docker run myimage echo "Hello, World!"
# → Запуск з аргументами: Hello, World!
$Hello, World!
----

[[docker-dockerfile-entrypoint-summary]]
Головне про `ENTRYPOINT`:

* Використовується для визначення основної команди, яка завжди виконується при запуску контейнера;
* Не перезаписується аргументами `docker run`, якщо не використовується `--entrypoint`;
* Дозволяє створити контейнер, який завжди виконує певну задачу;
* Може використовуватись разом з `CMD` для передачі аргументів до основної команди;
* Використовується для запуску процесів, які мають стартувати разом з контейнером;
* Може бути використано для запуску shell-скриптів, які приймають аргументи;
* Якщо в Dockerfile є декілька `ENTRYPOINT`, то буде використана остання команда;
* `ENTRYPOINT` може бути використано для запуску процесів, які мають стартувати разом з контейнером, наприклад, веб-серверів або баз даних;
* Якщо використовується разом з `CMD`, то `CMD` буде передаватися як аргументи до `ENTRYPOINT`;
* Якщо в Dockerfile є декілька `ENTRYPOINT`, то буде використана остання команда;
* `ENTRYPOINT` не виконується якщо використовується `--entrypoint`.

[[docker-dockerfile-entrypoint-best-practices]]
//TODO `ENTRYPOINT` Best Practices:

[[docker-dockerfile-cmd-vs-entrypoint]]
*`CMD` vs `ENTRYPOINT`*

|====
|Особливість|CMD|ENTRYPOINT
|Призначення|Команда за замовчуванням|Основна команда (завжди виконується)
|Перевизначення|Легко перевизначається через docker run|Може вимагати --entrypoint
|Взаємодія|Може передавати аргументи до ENTRYPOINT|Команду не можна легко змінити
|====

[[docker-dockerfile-copy]]
.`COPY`
[[docker-dockerfile-copy-definition]]*`COPY`* використовується в Dockerfile для копіювання файлів і директорій з локальної файлової системи (контексту збірки) в файлову систему образу. Головні особливості:

* Копіює файли/директорії з контексту збірки в контейнер;
* `--chown` дозволяє встановити власника та групу для скопійованих файлів;
* Не розпаковує архіви (.tar.gz, .zip тощо);
* Не підтримує URL, тобто не завантажує файли з Інтернету.

[[docker-dockerfile-add]]
.`ADD`
[[docker-dockerfile-add-definition]]*`ADD`* — інструкція Dockerfile, яка копіює файли з локального контексту збірки або з віддалених URL у файлову систему контейнера, але з додатковими можливостями, яких не має <<docker-dockerfile-copy,`COPY`>>. Головними особливостями `ADD` є:

* Копіює файли/директорії з контексту збірки в контейнер;
* Підтримує розпакування архівів (наприклад, .tar.gz) при копіюванні;
* Підтримує завантаження файлів з віддалених URL;
* Має параметр `--chown` для встановлення власника та групи для скопійованих файлів.
* Не розпаковує архіви з URL, тобто якщо ви вказуєте URL, то архів не буде розпакований.

[[docker-dockerfile-add-usage]]Деколька прикладів, якщо необхідно розпакувати архів:

[source,dockerfile]
----
ADD myapp.tar.gz /usr/src/myapp/
----

То результатом виконання буде:

[source,shell]
----
/usr/src/myapp/file1.txt
/usr/src/myapp/file2.txt
...
----

Але якщо ви вказуєте URL:

[source,dockerfile]
----
ADD https://example.com/myapp.tar.gz /usr/src/myapp/
----

то результатом буде:

[source,shell]
----
/usr/src/myapp/myapp.tar.gz
----

Тобто якщо архів вказаний в команді `ADD` розташований локально то він буде розпакований, але якщо він вказаний як URL, то він буде просто скопійований в контейнер без розпакування.

[[docker-dockerfile-copy-vs-add]]
*`COPY` vs `ADD`*
Відмінність між COPY та ADD:

* `COPY` копіює файли/директорії з контексту збірки в контейнер.
* `ADD` робить те ж саме, але також може автоматично розпаковувати архіви та завантажувати файли по URL. Рекомендується частіше використовувати `COPY` (більш передбачувано), `ADD` — тільки коли потрібні додаткові можливості.

Як результат можна зробити висновок, що:

* `COPY` — це простий і передбачуваний спосіб копіювання файлів з контексту збірки в контейнер;
* `ADD` — це більш потужний інструмент, який дозволяє розпаковувати архіви та завантажувати файли з URL, але може бути менш передбачуваним;
* Рекомендується використовувати `COPY` для простих копіювань, а `ADD` — тільки коли потрібні додаткові можливості, такі як розпакування архівів або завантаження файлів з URL.

[[docker-dockerfile-workdir]]
.`WORKDIR`
[[docker-dockerfile-workdir-definition]]*WORKDIR* встановлює робочу директорію всередині контейнера для наступних інструкцій (<<docker-dockerfile-run,RUN>>, <<docker-dockerfile-cmd,CMD>>, <<docker-dockerfile-entrypoint,ENTRYPOINT>> і т.д.). Якщо каталогу немає, він буде створений.

[[docker-dockerfile-expose]]
.`EXPOSE`
[[docker-dockerfile-expose-definition]]*EXPOSE* вказує, що контейнер слухає порт вказаний в цій команді. Це не впливає на роботу контейнера всередині Docker, але це корисно для читабельності та може враховуватися інструментами оркестрації.

[[docker-dockerfile-env]]
.`ENV`
[[docker-dockerfile-env-definition]]*ENV* встановлює змінні середовища для контейнера, які будуть доступні на етапі виконання контейнера (runtime).

Ці змінні:

* можуть використовуватись як під час збірки Dockerfile, так і в запущеному контейнері, оскільки зберігаються в образі;
* дозволяють задавати конфігураційні параметри, які можуть бути змінені при запуску контейнера;
* завжди присутні в контейнері, що робить його більш передбачуваним і “персистентним”;
* можуть бути використані в командах, додатках або скриптах, що працюють всередині контейнера.

Для перевизначення змінних середовища при запуску можна використати:

* `docker run -e KEY=VALUE`
* `docker run --env KEY=VALUE`

Також їх можна заздалегідь визначити в Dockerfile через:

[source,dockerfile]
----
ENV APP_HOME=/usr/src/app
WORKDIR $APP_HOME
RUN echo "App home is set to $APP_HOME"
----

[[docker-dockerfile-env-usage]]Головне призначення `ENV` — це встановлення змінних середовища, які будуть доступні на етапі виконання контейнера. Це дозволяє задавати конфігураційні параметри, які можуть бути змінені при запуску контейнера, і робить його більш передбачуваним і “персистентним”. Гнучкість для користувача: якщо ви хочете дозволити користувачам змінювати параметри роботи контейнера на етапі запуску, використовуйте `ENV`. Ці значення можна легко перевизначити за допомогою флага `-e` або через docker-compose.

[[docker-dockerfile-arg]]
.`ARG`
[[docker-dockerfile-arg-definition]]Для того щоб передати аргументи сборки в Dockerfile, використовуйте інструкцію *ARG*. При зборці передавайте *--build-arg*. Наприклад Dockerfile:

[source,dockerfile]
----
ARG APP_VERSION=latest
RUN echo "Version: $VERSION"
----

Сборка:

[source,shell]
----
docker build --build-arg APP_VERSION=1.2 .
----

[[docker-dockerfile-arg-usage]]Головне призначення `ARG` дозволяє задавати змінні на єтапі зборки образу (build-time). Ці змінні використовуються тільки під час зборки і не доступні коли образ зібран. Тобто ці змінні використовуються тільки в Dockerfile і не зберігаються в контейнері та недоступні під час виконання контейнера. Використання `ARG` є вірним вибором для зберігання сенсатів даних (токени, ключі API тощо) для того щоб вони не зберігалися в кінцевому образі. Але краще уникати використання таких даних в будь-якому вигляді, тому що навіть у випадку з `ARG`, ці дані можуть залишитися в історії збірки Docker-образу (наприклад, в проміжних шарах).

[[docker-dockerfile-arg-vs-env]]
*`ARG` vs `ENV`*
|====
|*Параметр*|*`ARG`*|*`ENV`*
|*Використання*|На етапі збірки образу|На етапі виконання контейнера
|*Доступность*|Доступны только на этапе сборки|Доступны на этапе выполнения контейнера
|*Перевизначення*|Можно переопределить с помощью `--build-arg` при сборке|Можно переопределить с помощью `-e` при запуске контейнера
|*Сохранение в образе*|Не сохраняется в образе|Сохраняется в образе
|*Цель*|Используется для передачи временных значений при сборке|Используется для задания окружения приложений внутри контейнера
|====

[[docker-dockerfile-arg-vs-env-best-practices]]
*`ARG`/`ENV` best practices:*

* Використовуйте `ARG` для змінних, які потрібні тільки на етапі збірки. Це хороший спосіб уникнути витоку даних, які не потрібні на етапі виконання.
* Використовуйте `ENV` для змінних, які потрібні на етапі виконання контейнера. Це дозволяє гнучко налаштовувати контейнер, передаючи параметри додатку та середовища.
* Мінімізуйте кількість змінних середовища `ENV`, що містять чутливі дані. Хоча `ENV` може бути зручним для передачі конфігурацій, це не найкращий спосіб для зберігання секретів, оскільки вони зберігаються в образі і можуть бути витягнуті. Краще використовувати секрети Docker (наприклад, через Docker Swarm або Kubernetes), якщо потрібно працювати з чутливими даними.
* Чітко розмежовуйте етапи збірки та виконання: Розуміння того, на якому етапі (збірки чи виконання) потрібні змінні, допоможе правильно вибрати між `ARG` і `ENV`.
* Використовуйте спільне використання `ARG` і `ENV`, коли потрібно передати значення на етапі збірки, а потім зберегти його для використання в контейнері.

[[docker-dockerfile-arg-vs-env-summary]]
*`ARG`/`ENV` Summary:*

* `ARG` — це змінні, які використовуються тільки на етапі збірки Dockerfile. Вони не зберігаються в кінцевому образі і не доступні під час виконання контейнера.
* `ENV` — це змінні середовища, які доступні на етапі виконання контейнера. Вони зберігаються в образі і можуть бути використані додатками всередині контейнера.

[[docker-dockerfile-user]]
.`USER`
[[docker-dockerfile-user-definition]]*`USER`* — визначає користувача, від імені якого будуть виконуватись усі наступні інструкції (<<docker-dockerfile-run,RUN>>, <<docker-dockerfile-cmd,CMD>>, <<docker-dockerfile-entrypoint,ENTRYPOINT>>, тощо), а також процес у контейнері під час запуску. Це дуже важлива інструкція для безпеки, тому що за замовченням все запускається від root користувача. Це зручно для встановлення пакетів але небеспечно для запуску додатків. Простий приклад:

[source,dockerfile]
----
FROM alpine

# Під root встановлюємо залежності
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

# Створюємо користувача
RUN adduser -D myuser

# Переключаємось
USER myuser

# Далі всі команди — без root-доступу
CMD ["echo", "Hello from myuser!"]
----

Коли використовуєш `USER` треба переконатись що користувач має права доступу до потрібних дерікторій:

[source,dockerfile]
----
FROM alpine

WORKDIR /app
RUN adduser -D myuser
USER myuser
RUN --chown=myuser:myuser /app
----

[[docker-dockerfile-volume]]
.`VOLUME`
[[docker-dockerfile-volume-definition]]*`VOLUME`* — створює точку монтування для зберігання даних, які не зберігаються в образі. Це дозволяє зберігати дані, які можуть змінюватись під час виконання контейнера, і робить їх доступними навіть після перезапуску контейнера. Наприклад:

[source,dockerfile]
----
VOLUME ["/data", "/logs"]
----

При цьому Docker створює нові томи для `/data` та `/logs`, монтує їх в вказану директорію в контейнері, дані в цих директоріях не зберігаються у шарах образу, а зберігаються в том. І при перезапуску контейнеру дані зберігаються. Але неможна задати ім'я тома, тому що Docker сам створює тома з випадковими іменами. Але за необхідністю можна створити <<docker-volume-named-volume,іменований тома>> вручну і підключити його до контейнера.

[[docker-dockerfile-label]]
.`LABEL`
[[docker-dockerfile-label-definition]]*`LABEL`* — використовується для додавання метаданих (інформації) до Docker-образу у вигляді пар ключ=значення. Ці дані не впливають на виконання контейнера, але корисні для ідентифікації, автоматизації та документування. Docker рекомендує OCI Image Specification для ключів:

[source,dockerfile]
----
LABEL org.opencontainers.image.title="My App" \
      org.opencontainers.image.description="Awesome app" \
      org.opencontainers.image.version="1.0.0" \
      org.opencontainers.image.licenses="MIT" \
      org.opencontainers.image.source="https://github.com/user/repo"
----

Для того щоб переглянути метадані образу, можна використати команду:

[source,shell]
----
docker inspect myimage --format='{{json .Config.Labels}}'
----

[[docker-dockerfile-healtcheck]]
.`HEALTHCHECK`
[[docker-dockerfile-healthcheck-definition]]*`HEALTHCHECK`* — це інструкція, яка дозволяє перевіряти “здоров’я” контейнера під час його роботи. Docker автоматично виконує команду перевірки з певним інтервалом і встановлює статус:

* ✅ healthy — контейнер працює коректно
* ⚠️ unhealthy — контейнер не відповідає
* ⏳ starting — контейнер ще запускається

Це дозволяє автоматично виявляти проблеми з контейнером і вживати заходів, наприклад, перезапускати його. Приклад використання:

[source,dockerfile]
----
FROM nginx:alpine

HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD curl -f http://localhost/ || exit 1
----

Для перевірки статусу здоров’я контейнера можна використати команду:

[source,shell]
----
docker inspect --format='{{json .State.Health}}' mycontainer
----

або

[source,shell]
----
docker ps
----

І як результат можна побачити статус здоров’я контейнера в колонці `STATUS`.

[source,shell]
----
Up 30 seconds (healthy)
Up 1 minute (unhealthy)
Up 10 seconds (starting)
----

Важливі нюанси:

* `HEALTHCHECK` не перезапускає контейнер автоматично (але можна налаштувати Docker Swarm/Kubernetes для рестарту при unhealthy);
* Впливає на CI/CD (деякі оркестратори чекають статусу healthy перед деплоєм);
* Використовуй легкі команди (перевірка має бути максимально швидкою (кілька секунд)
* Винось складну логіку в скрипт, наприклад:

[source,dockerfile]
----
COPY healthcheck.sh /usr/local/bin/
HEALTHCHECK CMD /usr/local/bin/healthcheck.sh
----

[[docker-dockerfile-shell]]
.`SHELL`
[[docker-dockerfile-shell-definition]]*`SHELL`* — визначає, яку командну оболонку (shell) Docker буде використовувати для виконання інструкцій на кшталт <<docker-dockerfile-run,RUN>>, <<docker-dockerfile-cmd,CMD>> та <<docker-dockerfile-entrypoint,ENTRYPOINT>> (коли вони задаються у shell-форматі). Тобто потрібен для того щоб змінити інтерпретатор команд, який буде використовуватись для виконання команд в Dockerfile. За замовчуванням це `/bin/sh -c`, але можна змінити на іншу оболонку, наприклад, `/bin/bash -c` або `/bin/zsh -c`. Приклад:

[source,dockerfile]
----
SHELL ["/bin/bash", "-c"]
RUN echo "Hello from bash" \
----

[[docker-dockerfile-testing]]Для того, щоб забезпечити якість Dockerfile ніж пушити до репозіторію, можна використовувати наступні підходи:

1. **Сборка образу**. Запустіть `docker build .` для зборки образу. Перевірте, що образ збирається без помилок.
2. **Запуск контейнера**. Запустіть контейнер зі збудованим образом через `docker run`. Перевірте, що контейнер запускається і працює коректно.
3. **Юніт-тести**. Напишіть юніт-тести для Dockerfile. Наприклад, використовуючи Molecule або Testcontainers.

[[docker-dockerfile-best-practices]]*Кращі практики при роботі в dockerfile:*

* Базовый образ — бери минимальный (alpine, slim, scratch), фиксируй версию, не используй latest;
* Меньше слоев — объединяй команды RUN, удаляй кеши и временные файлы;
* .dockerignore — исключай ненужные файлы (.git, node_modules, логи);
* Не root — создавай пользователя и запускай от него (USER app);
* ENTRYPOINT + CMD — разделяй основную команду и аргументы по умолчанию;
* Multi-stage build — собирай в одном образе, запускай в другом (минимальном);
* Безопасность — только нужные пакеты, без секретов в Dockerfile, регулярные обновления;
* Використовуйте `COPY` замість `ADD`, якщо не потрібно автоматичне розпакування архівів або завантаження з URL;
* Використовуйте `ARG` для передачі змінних збірки, щоб зробити Dockerfile більш гнучким.
